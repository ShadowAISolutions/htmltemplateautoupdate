# Chat Bookends (MANDATORY â€” EVERY PROMPT)

*Actionable rules for every response. Examples and summary tables in `chat-bookends-reference.md`.*

> **Feature toggle gate** â€” before emitting any bookend, check the Template Variables table:
> - If `CHAT_BOOKENDS` = `Off`: **skip all mid-response bookends** â€” CODING PLAN, CODING START, RESEARCH START, RESEARCHING, NEXT PHASE, CHECKLIST, BLOCKED, VERIFYING, CHANGES PUSHED, AWAITING HOOK, HOOK FEEDBACK, ESTIMATED TIME, REVISED ESTIMATED TIME, ACTUAL PLANNING TIME, PLAN APPROVED, and all `â±ï¸` duration annotations. Proceed directly to the work. The hook anticipation logic (running the three git commands) still executes â€” only its bookend output is suppressed. **Silent timestamp and estimate capture** â€” when `END_OF_RESPONSE_BLOCK` = `On`, the underlying data needed by end-of-response block features is still captured silently (no visible output): (a) run `date` at the very start of the response and internally note the **response start timestamp** â€” this replaces the CODING START/RESEARCH START timestamp for ACTUAL TOTAL COMPLETION TIME computation; (b) compute the overall estimate internally â€” this provides the parenthetical comparison value for ACTUAL TOTAL COMPLETION TIME and the baseline for ESTIMATE CALIBRATED; (c) if a revised estimate would be warranted (scope changed â‰¥1m after initial reads), internally note the revised value â€” it replaces the original for the parenthetical; (d) if a plan approval flow occurs, internally note the post-approval timestamp and post-approval estimate â€” these enable PLAN EXECUTION TIME. When `END_OF_RESPONSE_BLOCK` is also `Off`, skip the silent captures entirely â€” nothing consumes them
> - If `END_OF_RESPONSE_BLOCK` = `Off`: **skip the entire end-of-response block** â€” no `â”€â”€â”€â”€â”€` dividers, no END OF RESPONSE BLOCK header, no UNAFFECTED URLS, AGENTS USED, FILES CHANGED, COMMIT LOG, WORTH NOTING, SUMMARY, TODO, NEW FOLDERS, AFFECTED URLS, ESTIMATE CALIBRATED, PLAN EXECUTION TIME, ACTUAL TOTAL COMPLETION TIME, or closing marker (CODING COMPLETE / RESEARCH COMPLETE). Mid-response bookends (when `CHAT_BOOKENDS` = `On`) function fully and independently â€” they do not depend on the end-of-response block for any data or state
> - **Full independence** â€” the two toggles have zero cross-dependencies. Every feature of `END_OF_RESPONSE_BLOCK` works without `CHAT_BOOKENDS` (via silent timestamp/estimate capture), and every feature of `CHAT_BOOKENDS` works without `END_OF_RESPONSE_BLOCK`. No other system functionality depends on either toggle being in a specific state â€” both are purely output-presentation controls that gate what the user sees, not what data is collected
> - When both are `On` (the default), all rules below apply as written

- **First output â€” coding plan**: for every user prompt that will involve changes, the very first line written to chat must be `ğŸš©ğŸš©CODING PLANğŸš©ğŸš©` on its own line, followed by a brief bullet-point list of what will be done in this response, then a **blank line** followed by `âš¡âš¡CODING STARTâš¡âš¡` on its own line to signal work is beginning. The blank line is required to break out of the bullet list context so CODING START renders left-aligned. Keep the plan concise â€” one bullet per distinct action (e.g. "Edit CLAUDE.md to add coding plan rule", "Update README.md timestamp"). This is for transparency, not approval â€” do NOT wait for user confirmation before proceeding. If the response is purely informational with no changes to make, skip the plan and open with `ğŸ”¬ğŸ”¬RESEARCH STARTğŸ”¬ğŸ”¬` directly (instead of CODING START). **CODING PLAN and CODING START / RESEARCH START appear exactly once per response** â€” never repeat them mid-response. Use `ğŸ”„ğŸ”„NEXT PHASEğŸ”„ğŸ”„` instead (see below)
- **Planned affected URLs**: immediately after the coding plan bullets (after the blank line that ends the bullet list, before ESTIMATED TIME), output `ğŸ”—âœï¸PLANNED AFFECTED URLSâœï¸ğŸ”—` followed by the page URLs expected to be affected by this response â€” using the same label-URL pair format as the end-of-response `ğŸ”—âœï¸AFFECTED URLSâœï¸ğŸ”—` section (backtick-wrapped `âœï¸` labels, blockquoted URLs). **Show the current (pre-change) version** in the label â€” read the page's `html.version.txt` and append the version in parentheses: `` `âœï¸ Homepage (v01.13w)` ``. This gives the user clickable links to the files' current state and shows what version the page is at before changes begin. **Best-effort prediction** â€” base it on the coding plan bullets; if the scope changes mid-work, the final AFFECTED URLS at the end may differ. When no pages are expected to be affected, output the header followed by `> *No URL pages expected to be affected*`. **Skip entirely for RESEARCH START responses** (no plan, no affected URLs). When the coding plan repeats after `ğŸ“‹ğŸ“‹PLAN APPROVEDğŸ“‹ğŸ“‹`, include PLANNED AFFECTED URLS again after those plan bullets (the prediction may be more accurate post-research)
- **Continuation after user interaction**: when `AskUserQuestion` or `ExitPlanMode` returns mid-response (the user answered a question or approved a plan), the response continues but must **NOT** repeat `ğŸš©ğŸš©CODING PLANğŸš©ğŸš©`, `âš¡âš¡CODING STARTâš¡âš¡`, or `ğŸ”¬ğŸ”¬RESEARCH STARTğŸ”¬ğŸ”¬`. Instead:
  - After `AskUserQuestion`: use `ğŸ”„ğŸ”„NEXT PHASEğŸ”„ğŸ”„` with a description incorporating the user's choice (e.g. "User chose option A â€” proceeding with implementation")
  - After `ExitPlanMode` (plan approved): output `ğŸ“‹ğŸ“‹PLAN APPROVEDğŸ“‹ğŸ“‹` on its own line, followed by `ğŸš©ğŸš©CODING PLANğŸš©ğŸš©` with the execution plan bullets, then `âš¡âš¡CODING STARTâš¡âš¡`. This is the **only** scenario where CODING PLAN/CODING START may appear a second time â€” because plan approval is a distinct boundary between planning and execution, and the user needs to see the execution plan clearly. The `ğŸ“‹ğŸ“‹PLAN APPROVEDğŸ“‹ğŸ“‹` marker signals that this is a continuation, not a new prompt. **Fresh timestamps required** â€” run `date` once for PLAN APPROVED, then run `date` again for the post-approval CODING PLAN + CODING START pair (a single call covers both, same as the initial opening pair rule). Do NOT reuse the PLAN APPROVED timestamp for CODING START â€” there is a gap between plan approval and the start of execution (the coding plan bullets and estimated time are written in between), so the timestamps will differ. PLAN EXECUTION TIME is computed from the post-approval start timestamp (whether displayed via CODING START or silently captured), so an inaccurate timestamp here inflates or deflates the reported execution time
- **Checklist running**: output `âœ”ï¸âœ”ï¸CHECKLISTâœ”ï¸âœ”ï¸` on its own line before executing any mandatory checklist (Session Start, Pre-Commit, Pre-Push), followed by the checklist name (e.g. `Session Start Checklist`). This separates checklist overhead from the user's actual task. Output once per checklist invocation. **`â±ï¸` must precede this bookend** (see Duration annotations)
- **Researching**: output `ğŸ”ğŸ”RESEARCHINGğŸ”ğŸ”` on its own line when entering a research/exploration phase â€” reading files, searching the codebase, or understanding context before making changes. Skip if going straight to changes without research. **`â±ï¸` must precede this bookend** (see Duration annotations)
- **Mid-response phase marker**: when work within a single response naturally divides into multiple distinct sub-tasks or phases (e.g. "Edit 1" then "Edit 1a: fix related issue"), output `ğŸ”„ğŸ”„NEXT PHASEğŸ”„ğŸ”„` on its own line followed by a brief description of the new phase. **Never repeat** `ğŸš©ğŸš©CODING PLANğŸš©ğŸš©`, `âš¡âš¡CODING STARTâš¡âš¡`, or `ğŸ”¬ğŸ”¬RESEARCH STARTğŸ”¬ğŸ”¬` within the same response â€” those appear exactly once (at the very top). The mid-response marker keeps the top/bottom boundaries of each prompt/response turn unambiguous while still signaling transitions between sub-tasks. **`â±ï¸` must precede this bookend** (see Duration annotations)
- **Blocked**: output `ğŸš§ğŸš§BLOCKEDğŸš§ğŸš§` on its own line when an obstacle is hit (permission denied, merge conflict, ambiguous requirement, failed push, hook check failure). Follow with a brief description of the blocker. This makes problems immediately visible rather than buried in tool output. **`â±ï¸` must precede this bookend** (see Duration annotations)
- **Verifying**: output `ğŸ§ªğŸ§ªVERIFYINGğŸ§ªğŸ§ª` on its own line when entering a verification phase â€” running git hook checks, confirming no stale references, validating edits post-change. Separates "doing the work" from "checking the work". **`â±ï¸` must precede this bookend** (see Duration annotations)
- **Changes pushed**: output `â¡ï¸â¡ï¸CHANGES PUSHEDâ¡ï¸â¡ï¸` on its own line **immediately** after a successful `git push` completes. This gives the user instant visibility that their changes are on the remote â€” no need to scroll through tool output to confirm. Follow with a brief note of what was pushed (e.g. "Pushed to `claude/cleanup-xyz` â€” workflow will auto-merge to main"). This bookend is a timestamped marker like any other â€” run `date` before writing it. It participates in `â±ï¸` duration tracking (the previous phase's `â±ï¸` appears before it, and the next bookend's `â±ï¸` measures from it)
- **Time estimate**: output `â³â³ESTIMATED TIME â‰ˆ Xmâ³â³` on its own line, followed by a brief reason (e.g. "~8 file edits + commit + push cycle"), in **two contexts**: (1) **Overall** â€” **always** appears immediately before the opening marker (`âš¡âš¡CODING STARTâš¡âš¡` or `ğŸ”¬ğŸ”¬RESEARCH STARTğŸ”¬ğŸ”¬`), estimating the entire response from start to the closing marker. This gives the user an upfront sense of total wall-clock time. The overall estimate is **never skipped** â€” even for quick responses (e.g. `â³â³ESTIMATED TIME â‰ˆ 1mâ³â³`). Use `Xm` for minutes or `Xs` for estimates under 1 minute. (2) **Per-phase** â€” immediately before any subsequent phase bookend (NEXT PHASE, RESEARCHING, CHECKLIST, etc.) whose phase alone is expected to take longer than 2 minutes. **Only output per-phase estimates when the estimate exceeds 2 minutes** â€” skip for phases that will be quick. Use these rough heuristics to estimate: ~10s per tool call (read, edit, grep, glob), ~15s per bash command, ~30s per commit cycle (checklist + staging + commit), ~30s per push cycle (checklist + push + verify), ~1â€“2m per subagent spawn. Sum the expected tool calls for the phase and round to the nearest minute. The estimate does not need a timestamp or `date` call â€” it is an annotation, not a bookend that participates in `â±ï¸` duration tracking
- **Revised estimate**: once all initial file reads, greps, and exploration needed to understand the scope of work are complete â€” regardless of whether a RESEARCHING bookend was used â€” re-evaluate the overall estimate. If it now differs from the original by â‰¥1 minute, output `â³â³REVISED ESTIMATED TIME â‰ˆ Xmâ³â³ [HH:MM:SS AM/PM EST]` on its own line with a brief reason (e.g. "~12 files to edit, not 4 as initially expected"). **Run `date` before writing the line** â€” this is a timestamped marker like any other bookend. Place it inline right after the last read/exploration tool result and before the next action or bookend. **Skip if the original estimate still looks accurate.** The revised estimate replaces the original as the baseline for the ACTUAL TOTAL COMPLETION TIME comparison at the end
- **Actual time**: output `â³â³ACTUAL TOTAL COMPLETION TIME: Xm Ys (estimated Xm)â³â³` on its own line immediately before the closing marker (`âœ…âœ…CODING COMPLETEâœ…âœ…` or `ğŸ”¬ğŸ”¬RESEARCH COMPLETEğŸ”¬ğŸ”¬`). This is the real elapsed wall-clock time from the response start timestamp to the closing marker â€” computed by subtracting the response start timestamp from the closing marker's timestamp. The response start timestamp is captured by CODING START/RESEARCH START when `CHAT_BOOKENDS` = `On`, or silently via `date` at response start when `CHAT_BOOKENDS` = `Off` (see feature toggle gate). The parenthetical shows the original overall estimate for easy comparison (captured visibly or silently depending on the `CHAT_BOOKENDS` toggle). If a REVISED ESTIMATED TIME was issued, use the revised value instead. **Always present** when CODING COMPLETE or RESEARCH COMPLETE is written (never skipped). **Not present** before AWAITING USER RESPONSE â€” that ending uses ACTUAL PLANNING TIME instead. The `date` call for the closing marker (already required) provides the end time â€” no additional `date` call is needed
- **Plan execution time** (conditional): when a plan approval flow was used (`ExitPlanMode` â†’ `ğŸ“‹ğŸ“‹PLAN APPROVEDğŸ“‹ğŸ“‹`), the end-of-response block must include **both** time markers in this order: (1) `â³â³PLAN EXECUTION TIME: Xm Ys (estimated Xm)â³â³` â€” the wall-clock time from the post-approval start timestamp (captured by CODING START when `CHAT_BOOKENDS` = `On`, or silently when `CHAT_BOOKENDS` = `Off`) to CODING COMPLETE, with the post-approval estimate as the parenthetical, then (2) `â³â³ACTUAL TOTAL COMPLETION TIME: Xm Ys (estimated Xm)â³â³` â€” the sum of the ACTUAL PLANNING TIME and the PLAN EXECUTION TIME, with the original overall estimate (from the response start) as the parenthetical. **Skip PLAN EXECUTION TIME entirely when no plan approval occurred** â€” responses without `ExitPlanMode` only show ACTUAL TOTAL COMPLETION TIME as usual
- **Estimate calibration**: after computing ACTUAL TOTAL COMPLETION TIME, if the actual and estimated times differ by **more than 2 minutes**, perform a calibration step **before** writing CODING COMPLETE. This makes estimation accuracy self-improving over time:
  1. **Diagnose the miss** â€” identify what caused the gap. Common causes: underestimating the number of file reads needed, not accounting for checklist overhead, forgetting the push cycle, unexpected retries or errors, or heuristic values being too low/high for the type of work done
  2. **Update the heuristics** â€” edit the Time estimate bullet's heuristic values in this file to better reflect reality. For example, if tool calls consistently take ~15s instead of ~10s, change `~10s per tool call` to `~15s per tool call`. If commit cycles consistently take ~45s, update `~30s per commit cycle` to `~45s per commit cycle`. Only change values where the evidence from this response supports the adjustment â€” do not guess or over-correct
  3. **Output the calibration** â€” in the end-of-response block, output `ğŸ”§ğŸ”§ESTIMATE CALIBRATEDğŸ”§ğŸ”§` after SUMMARY and before ACTUAL TOTAL COMPLETION TIME, followed by a brief description of what was adjusted and why (e.g. "Increased tool call estimate from ~10s to ~15s â€” actual tool calls averaged 14s this response"). This makes the self-correction visible to the user
  4. **Commit the update** â€” include the heuristic change in the current commit (or make a follow-up commit if the main commit already happened). The updated heuristics take effect starting from the next response
  **Skip calibration entirely if the difference is â‰¤2 minutes** â€” small variances are normal and not worth correcting
- **Hook anticipation**: before writing the closing marker (`âœ…âœ…CODING COMPLETEâœ…âœ…` or `ğŸ”¬ğŸ”¬RESEARCH COMPLETEğŸ”¬ğŸ”¬`), check whether the stop hook (`~/.claude/stop-hook-git-check.sh`) will fire. **This check must happen after all actions in the current response are complete** (including any `git push`) â€” do not predict the pre-action state; check the actual post-action state. **Actually run** the three git commands (do not evaluate mentally): (a) uncommitted changes â€” `git diff --quiet && git diff --cached --quiet`, (b) untracked files â€” `git ls-files --others --exclude-standard`, (c) unpushed commits â€” `git rev-list origin/<branch>..HEAD --count`. If any condition is true, **omit** the closing marker and instead write `ğŸŸğŸŸAWAITING HOOKğŸŸğŸŸ` as the last line of the current response â€” the hook will fire, and the appropriate closing marker (CODING COMPLETE or RESEARCH COMPLETE) should close the hook feedback response instead. **Do not forget the `â±ï¸` duration annotation** â€” AWAITING HOOK is a bookend like any other, so the previous phase's `â±ï¸` must appear immediately before it. After the hook anticipation git commands complete, call `date`, compute the duration since the previous bookend's timestamp, write the `â±ï¸` line, then write AWAITING HOOK
- **Compaction recovery override**: if the conversation context has been compacted (session summary replacing earlier messages), use `ğŸ”ƒğŸ”ƒCONTEXT COMPACTION RECOVERYğŸ”ƒğŸ”ƒ` as the first line (with time+date timestamp) instead of any other opener. This replaces CODING PLAN, CODING START, RESEARCH START, and HOOK FEEDBACK as the response opener. After the bookend, re-read CLAUDE.md rules (per the Session Start Checklist compaction recovery bullet), then resume the interrupted task â€” output `ğŸ”„ğŸ”„NEXT PHASEğŸ”„ğŸ”„` to signal resumption and continue working. **Do not re-show reminders** â€” they were already surfaced earlier in the session before compaction. **Do not redo completed work** â€” use the compacted summary to understand what was already accomplished and pick up where the interruption occurred
- **Hook feedback override**: if the triggering message is hook feedback (starts with "Stop hook feedback:", "hook feedback:", or contains `<user-prompt-submit-hook>`), use `âš“âš“HOOK FEEDBACKâš“âš“` as the first line instead of `ğŸš©ğŸš©CODING PLANğŸš©ğŸš©`, `âš¡âš¡CODING STARTâš¡âš¡`, or `ğŸ”¬ğŸ”¬RESEARCH STARTğŸ”¬ğŸ”¬`. The coding plan (if applicable) follows immediately after `âš“âš“HOOK FEEDBACKâš“âš“`, then `âš¡âš¡CODING STARTâš¡âš¡`
- **End-of-response sections**: after all work is done, output the following sections in this exact order. **Skip the entire block when the response ends with RESEARCH COMPLETE or AWAITING USER RESPONSE** â€” those endings have no end-of-response block. **The entire block â€” from the divider through CODING COMPLETE â€” must be written as one continuous text output with no tool calls in between.** To achieve this, run the `date` command for CODING COMPLETE's timestamp **before** starting the block, then output: the last phase's `â±ï¸` duration, a backtick-wrapped divider line `` `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€` `` on its own line, then `` `END OF RESPONSE BLOCK` `` on the next line (backtick-wrapped for red/accent styling), then another backtick-wrapped divider `` `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€` `` on the next line. This three-line header visually separates work phases from the end-of-response block. Then output UNAFFECTED URLS through CODING COMPLETE using the pre-fetched timestamp:
  - **Unaffected URLs**: output `ğŸ”—ğŸ›¡ï¸UNAFFECTED URLSğŸ›¡ï¸ğŸ”—` followed by reference URLs and **unaffected** page URLs (pages without `âœï¸`). **Always present** in every response that ends with CODING COMPLETE â€” never skipped. This is the first section after the divider, giving the user immediate one-click access to the live site. See the Unaffected/Affected URLs bullet below for full rules on content and formatting
  - **Agents used**: output `ğŸ•µğŸ•µAGENTS USEDğŸ•µğŸ•µ` followed by a **numbered list** of all agents that contributed to this response â€” including Agent 0 (Main). Format: `1. Agent N (Type) â€” brief description of contribution`. Number each agent sequentially starting from 1. This appears in every response that ends with CODING COMPLETE
  - **Files changed**: output `ğŸ“ğŸ“FILES CHANGEDğŸ“ğŸ“` followed by a list of every file modified in the response, each tagged with the type of change: `(edited)`, `(created)`, or `(deleted)`. This gives a clean at-a-glance file manifest. Skip if no files were changed in the response
  - **Commit log**: output `ğŸ“œğŸ“œCOMMIT LOGğŸ“œğŸ“œ` followed by a list of every commit made in the response. Each entry format: `SHA: [SHORT_SHA](https://github.com/ORG/REPO/commit/FULL_SHA) â€” commit message`. The `SHA:` label makes it clear that the linked text is a commit SHA (Secure Hash Algorithm identifier). Do NOT backtick-wrap the SHA text â€” use a plain markdown link so it renders as a clickable link (not red/accent). Get the full SHA via `git rev-parse SHORT_SHA` and resolve `ORG/REPO` from `git remote -v`. Skip if no commits were made in the response
  - **Worth noting**: output `ğŸ”–ğŸ”–WORTH NOTINGğŸ”–ğŸ”–` followed by a list of anything that deserves attention but isn't a blocker (e.g. "Push-once already used â€” did not push again", "Template repo guard skipped version bumps", "Pre-commit hook modified files â€” re-staged"). Skip if there are nothing worth noting
  - **Summary of changes**: output `ğŸ“ğŸ“SUMMARYğŸ“ğŸ“` on its own line followed by a concise bullet-point summary of all changes applied in the current response. Each bullet must indicate which file(s) were edited (e.g. "Updated build-version in `live-site-pages/index.html`"). If a bullet describes a non-file action (e.g. "Pushed to remote"), no file path is needed
  - **To-do list**: output `ğŸ“‹ğŸ“‹TODOğŸ“‹ğŸ“‹` on its own line followed by the current contents of `repository-information/TODO.md`. Read the file before starting the end-of-response block (this is an exception to the "no tool calls" rule â€” read TODO.md alongside the `date` call, before beginning the block output). **Display rules**: (1) If the file contains `*(No items yet)*` or has no items, output the header followed by `> *No to-do items*`. (2) If the file has items, list each one as a checkbox: `- [ ] Item text` for outstanding items. (3) **Completed items**: if the current response accomplished any to-do item, show it crossed off **in its original list position**: `- [x] ~~Item text~~`. The crossed-out item stays where it was in the list â€” do not move it to the top or bottom. After writing the end-of-response block, remove the completed items from `TODO.md` (this is a second exception to the "no tool calls" rule â€” edit TODO.md after the block but before the very next response). If all items are completed, restore the `*(No items yet)*` placeholder. (4) **Maximum 10 items** â€” TODO.md should never have more than 10 active items. If the user requests adding an 11th, flag it and ask which item to replace or defer. (5) Items in TODO.md use a simple format: `- Item text` (one per line, no checkboxes in the file itself â€” checkboxes are only used in the end-of-response display)
  - **New folders**: output `ğŸ“‚ğŸ“‚NEW FOLDERSğŸ“‚ğŸ“‚` on its own line followed by a list of every new directory created in the repo during this response. Each entry is a clickable markdown link to the folder's tree-view on GitHub: `[folder/path/](https://github.com/ORG/REPO/tree/main/folder/path)`. Resolve `ORG` and `REPO` from `git remote -v`. **Only show when folders were created** â€” skip this section entirely (no header, no placeholder) if no new directories were created in the response
  - **Affected URLs**: output `ğŸ”—âœï¸AFFECTED URLSâœï¸ğŸ”—` followed by only the page URLs that were affected by changes in this response (the ones that would have the `âœï¸` indicator). **Always present** â€” when no pages were affected, output the header followed by a placeholder: `> *No URL pages were affected in this response*`. See the Unaffected/Affected URLs bullet below for full rules on the affected/unaffected split
  - **Section separation** â€” a **blank line** must appear between every end-of-response section (after the last content line of one section and before the next section's header). This breaks markdown list context and prevents cascading indentation â€” without it, the numbered list under AGENTS USED causes all subsequent sections to render as nested list items. Content within each section has **no leading spaces** (flush-left). The blank line rule applies between every pair: UNAFFECTED URLS â†’ AGENTS USED â†’ FILES CHANGED â†’ COMMIT LOG â†’ WORTH NOTING â†’ SUMMARY â†’ TODO â†’ NEW FOLDERS â†’ AFFECTED URLS
  - **Estimate calibration** (conditional): if ACTUAL TOTAL COMPLETION TIME differs from the estimate by >2 minutes, output `ğŸ”§ğŸ”§ESTIMATE CALIBRATEDğŸ”§ğŸ”§` followed by what was adjusted. This is the **one exception** to the "no tool calls in the end-of-response block" rule â€” the calibration edits CLAUDE.md's heuristic values via an Edit tool call between AFFECTED URLS and ACTUAL TOTAL COMPLETION TIME. See the Estimate calibration bullet above for the full procedure
- **Unaffected/Affected URLs (split into two sections)**: the URLs are split into an **unaffected** group and an **affected** group, appearing in different positions within the end-of-response block. **Both are skipped when the response ends with RESEARCH COMPLETE or AWAITING USER RESPONSE.** Rules:
  - **Unaffected group** â€” `ğŸ”—ğŸ›¡ï¸UNAFFECTED URLSğŸ›¡ï¸ğŸ”—`: appears immediately after the divider, **before AGENTS USED**. Contains reference URLs and all **unaffected** page URLs (pages without `âœï¸`). **Always present** when the response ends with CODING COMPLETE â€” never skipped. When all pages are affected (no unaffected page URLs to show), the reference URLs still appear followed by a placeholder after the reference URL divider: `> *No URL pages were unaffected in this response*`
  - **Affected group** â€” `ğŸ”—âœï¸AFFECTED URLSâœï¸ğŸ”—`: appears **after SUMMARY**. Contains only the page URLs that were affected by changes in this response (the ones with the `âœï¸` indicator). **Always present** â€” when no pages were affected (e.g. "No site changes" responses), output the header followed by a placeholder: `> *No URL pages were affected in this response*`
  - **Reference URLs** (always shown in the unaffected group):
    - `` `Template Repo` `` on its own line (backtick-wrapped â€” renders as red/accent label in the CLI, no `>` prefix), followed by the URL on the next line in a blockquote (`>`): [github.com/ShadowAISolutions/htmltemplateautoupdate](https://github.com/ShadowAISolutions/htmltemplateautoupdate) (always this fixed URL â€” it's the origin template). The visible text omits `https://` â€” the markdown link provides the full URL
    - `` `Repository` `` on its own line (no `>` prefix), followed by the URL on the next line in a blockquote (`>`)
    - **On the template repo**, the Template and Repository URLs are identical â€” merge them into a single label: `` `Template & Repository` `` on its own line, followed by the URL in a blockquote on the next line
    - **Reference URL divider** â€” after the URL line of `` `Template & Repository` ``, `` `Template Repo` ``, or `` `Repository` `` (whichever is last among the reference URLs), insert a blank line to exit the blockquote context, then a plain (non-backtick-wrapped) 25-character `â”€` divider line on its own line: `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`. The blank line is critical â€” without it, the divider would be interpreted as a continuation of the blockquote. The divider sits at the top level (no `>` prefix), visually separating the reference URLs from the page URLs. It renders as regular white text (not red/accent) because it is not backtick-wrapped. **When no unaffected pages exist** (all pages are affected), the divider still appears â€” it separates reference URLs from AGENTS USED visually
    - **Display format for all URLs** â€” visible text never includes `https://`. The full URL is always preserved in the markdown link target. Format: `[domain/path](https://domain/path)`. This applies to reference URLs, live site URLs, and all other URLs in both sections
    - **Label-URL pair format** â€” every entry (reference URLs and page URLs) uses a two-line format separated by blank lines between pairs: (1) backtick-wrapped label on its own line with no blockquote prefix (renders as red/accent text in the CLI), (2) the URL on the next line inside a single-level blockquote (`>`). A blank line between each pair resets the blockquote context, so every label starts fresh at the top level with its URL visually indented beneath it. The red labels act as natural visual dividers between entries
  - **Unaffected page URLs** (in the `ğŸ”—ğŸ›¡ï¸UNAFFECTED URLSğŸ›¡ï¸ğŸ”—` section): list every page in `live-site-pages/` that was **not** affected by changes in this response, using the label-URL pair format. **Show the current version** in the label â€” read the page's `html.version.txt` and append the version in parentheses: `` `Homepage (v01.13w)` ``. When no unaffected pages exist (all pages were affected), output a placeholder after the reference URL divider: `> *No URL pages were unaffected in this response*`. Use `` `Homepage (vXX.XXw)` `` as the label for the root `index.html`, or `` `Project Name | Homepage (vXX.XXw)` `` for subdirectory pages (e.g. `` `My Project | Homepage (v01.05w)` ``). Labels have no `>` prefix; URLs use `>`. The `live-site-pages/` directory is deployed as the site root, so this prefix is never part of the URL. Resolve `YOUR_ORG_NAME` and `YOUR_REPO_NAME` from the Template Variables table (using the real values from `git remote -v` on non-template repos, or the actual `ShadowAISolutions`/`htmltemplateautoupdate` values on the template repo). Rules:
    - **When the live site is deployed** (non-template repos): label on its own line (no `>`), then the URL in a blockquote on the next line â€” e.g. `` `Homepage (v01.13w)` `` followed by `> [index.html](https://github.com/ORG/REPO/blob/main/live-site-pages/index.html) â†’` [YOUR_ORG_NAME.github.io/YOUR_REPO_NAME/](https://YOUR_ORG_NAME.github.io/YOUR_REPO_NAME/)
    - **When no live site is deployed** (template repo with `TEMPLATE_DEPLOY` = `Off`): label on its own line (no `>`), then a non-clickable note in a blockquote â€” e.g. `` `Homepage (v01.00w)` `` followed by `> [index.html](https://github.com/ORG/REPO/blob/main/live-site-pages/index.html) â†’ (template repo â€” no live site deployed)`
    - **When template deploy is enabled** (template repo with `TEMPLATE_DEPLOY` = `On`): show the live URL just like a non-template repo, but append a toggle indicator â€” e.g. `` `Homepage (v01.13w)` `` followed by `> [index.html](https://github.com/ORG/REPO/blob/main/live-site-pages/index.html) â†’` [ShadowAISolutions.github.io/htmltemplateautoupdate/](https://ShadowAISolutions.github.io/htmltemplateautoupdate/) `(TEMPLATE_DEPLOY: On)`. The `(TEMPLATE_DEPLOY: On)` note is backtick-wrapped for red/accent styling, reminding the user that deployment is active via the toggle. For affected pages, the same pattern applies with `âœï¸` and the new version in the label
    - For pages in subdirectories (e.g. `live-site-pages/my-project/index.html`): `` `My Project | Homepage (v01.05w)` `` followed by `> [my-project/index.html](https://github.com/ORG/REPO/blob/main/live-site-pages/my-project/index.html) â†’` [YOUR_ORG_NAME.github.io/YOUR_REPO_NAME/my-project/](https://YOUR_ORG_NAME.github.io/YOUR_REPO_NAME/my-project/)
  - **Affected page URLs** (in the `ğŸ”—âœï¸AFFECTED URLSâœï¸ğŸ”—` section): list only pages affected by changes in this response â€” either directly (the HTML file itself was edited) or indirectly (a `.gs`/`.gas` file whose output is embedded in the page was edited, or a resource the page depends on was changed). Prepend `âœï¸` inside the backtick-wrapped label **and append the new version the page becomes** in parentheses. The version shown is the **post-bump version** â€” the version the page will have after deployment. Read the page's `html.version.txt` (which has already been bumped by Pre-Commit #2 at this point) to get the value. For GAS-only changes (indirect affect), show the GAS version instead: `(XX.XXg)`. When both page and GAS versions were bumped, show both: `(vXX.XXw Â· XX.XXg)`. Examples: `` `âœï¸ Homepage (v01.14w)` `` on its own line (no `>`), then `> [index.html](...) â†’` [ORG.github.io/REPO/](https://ORG.github.io/REPO/) on the next line. For GAS-only: `` `âœï¸ Homepage (01.14g)` ``. For both: `` `âœï¸ Homepage (v01.14w Â· 01.14g)` ``. For subpages: `` `âœï¸ My Project | Homepage (v01.02w)` `` followed by the URL line in `>`. The `âœï¸` inside the red/accent label is unmissable â€” it combines the accent color with the emoji for maximum visibility. The version in the label tells the user exactly what version their page is moving to. **Indirect affects**: use the GAS Projects table to determine which embedding page a `.gs` file maps to â€” if a `.gs` file was edited, its registered embedding page gets the indicator even though the HTML file wasn't touched, because the user-facing experience of that page changed
  - **`.gs` files**: if a `.gs` file was edited, also note its associated embedding HTML page (from the GAS Projects table) next to the page URL in the affected group. If the `.gs` file has no registered embedding page, note it separately
  - **File path links**: every file path shown in either section must be a clickable markdown link to the file's blob-view on GitHub. The URL uses the full path: `https://github.com/ORG/REPO/blob/main/FULL_PATH`. The **link text** depends on the file's location within `live-site-pages/`: for files directly in `live-site-pages/` (no subdirectory), show just the filename (e.g. `index.html`); for files in a subdirectory, show the **containing folder + filename** (e.g. `my-project/index.html`). This gives the user enough context to identify which page the link refers to without showing the full repo path. Resolve `ORG` and `REPO` from `git remote -v` (using the actual values, e.g. `ShadowAISolutions/htmltemplateautoupdate` on the template repo). Examples: `[index.html](https://github.com/ShadowAISolutions/htmltemplateautoupdate/blob/main/live-site-pages/index.html)`, `[my-project/index.html](https://github.com/MyOrg/my-repo/blob/main/live-site-pages/my-project/index.html)`, `[index.gs](https://github.com/MyOrg/my-repo/blob/main/googleAppsScripts/MyProject/index.gs)`
  - **Blockquote formatting**: URL lines use a single-level blockquote (`>` prefix). Labels do NOT use a blockquote prefix â€” they sit at the top level so the URL appears visually indented beneath them. A blank line separates each label/URL pair to reset the blockquote context. Both `ğŸ”—ğŸ›¡ï¸UNAFFECTED URLSğŸ›¡ï¸ğŸ”—` and `ğŸ”—âœï¸AFFECTED URLSâœï¸ğŸ”—` headings are NOT blockquoted
  - **CLI red/accent text technique**: backtick-wrapped text renders with red/accent styling in the Claude Code CLI. Labels use this at the top level (no `>`) â€” they still get the red treatment. *Full reference: see `.claude/rules/output-formatting.md` â€” section "CLI Accent Styling Reference"*
  - **Format**: each entry is a two-line pair separated by blank lines. Line 1: backtick-wrapped label at top level (no `>`, red/accent in CLI). Line 2: the URL in a blockquote (`>`). In the affected group: `` `âœï¸ Homepage (v01.14w)` `` then `> [index.html](https://github.com/.../blob/main/live-site-pages/index.html) â†’` [ShadowAISolutions.github.io/htmltemplateautoupdate/](https://ShadowAISolutions.github.io/htmltemplateautoupdate/). In the unaffected group: `` `Homepage (v01.13w)` `` then `> [index.html](https://github.com/.../blob/main/live-site-pages/index.html) â†’ ...`. For subpages in the affected group: `` `âœï¸ My Project | Homepage (v01.02w)` `` then `> [my-project/index.html](https://github.com/.../blob/main/live-site-pages/my-project/index.html) â†’` [ORG.github.io/REPO/my-project/](https://ORG.github.io/REPO/my-project/)
  - Both sections are part of the end-of-response block â€” they do **not** get timestamps or `â±ï¸` annotations
- **Last output**: every response must end with exactly one of the following closing markers on its own line â€” which one depends on the response type:
  - `âœ…âœ…CODING COMPLETEâœ…âœ…` â€” the response made code changes, file edits, commits, or pushes (i.e. any non-trivial action beyond pure research)
  - `ğŸ”¬ğŸ”¬RESEARCH COMPLETEğŸ”¬ğŸ”¬` â€” the response was purely informational â€” answered a question, explained code, researched a topic, or provided guidance with **no** file changes, commits, or pushes. When this ending is used, the full end-of-response block (UNAFFECTED URLS through SUMMARY) is **skipped** â€” write only RESEARCH COMPLETE as the final line (with its timestamp). The ESTIMATED TIME and ACTUAL TOTAL COMPLETION TIME rules still apply: output ESTIMATED TIME before RESEARCH START as usual, and output ACTUAL TOTAL COMPLETION TIME immediately before RESEARCH COMPLETE
  - `â¸ï¸â¸ï¸AWAITING USER RESPONSEâ¸ï¸â¸ï¸` â€” the response ends with a question to the user via `AskUserQuestion` (not mid-response, but as the **final action** â€” no more work follows in this response). When this ending is used, output the `â±ï¸` duration and `â³â³ACTUAL PLANNING TIMEâ³â³` before the `AskUserQuestion` call (per the "Duration before user interaction" rule), then after the user answers, the continuation response opens with `ğŸ”„ğŸ”„NEXT PHASEğŸ”„ğŸ”„` as normal. **Do not write the end-of-response block before AWAITING USER RESPONSE** â€” it belongs to the continuation response that finishes the work. The `â¸ï¸â¸ï¸AWAITING USER RESPONSEâ¸ï¸â¸ï¸` line is written immediately before the `AskUserQuestion` tool call
- **Post-closing markers** â€” certain actions produce a marker **after** the closing marker (`âœ…âœ…CODING COMPLETEâœ…âœ…` or `ğŸ”¬ğŸ”¬RESEARCH COMPLETEğŸ”¬ğŸ”¬`). These are exceptional â€” the closing marker is normally the last line. Currently the only post-closing marker is:
  - `ğŸ’¡ğŸ’¡SESSION SAVEDğŸ’¡ğŸ’¡` â€” output on its own line immediately after `âœ…âœ…CODING COMPLETEâœ…âœ…` when the response performed a "Remember Session" action. Follow with the message: *"Session context saved. It's recommended to start a new session now so you don't lose the context we just created. Your next session will automatically pick up where we left off."* This placement ensures the user cannot miss the session-save confirmation â€” it's the absolute last thing they see
- These apply to **every single user message**, not just once per session
- These bookend lines are standalone â€” do not combine them with other text on the same line
- **Timestamps on bookends** â€” every bookend marker must include a real EST timestamp on the same line, placed after the marker text in square brackets. **Five bookends get time+date** (format: `[HH:MM:SS AM/PM EST MM/DD/YYYY]`): CODING PLAN, CODING START, RESEARCH START, CODING COMPLETE, and RESEARCH COMPLETE. **All other bookends (including REVISED ESTIMATED TIME) get time-only** (format: `[HH:MM:SS AM/PM EST]`). **You must run `date` via the Bash tool and get the result BEFORE writing the bookend line** â€” you have no internal clock, so any timestamp written without calling `date` first is fabricated. Use `TZ=America/New_York date '+%I:%M:%S %p EST %m/%d/%Y'` for the time+date bookends and `TZ=America/New_York date '+%I:%M:%S %p EST'` for time-only bookends. Do not guess, estimate, or anchor on times mentioned in the user's message. The small delay before text appears is an acceptable tradeoff for accuracy. For the opening pair (CODING PLAN + CODING START, or RESEARCH START alone), a single `date` call is sufficient â€” run it once before any text output and reuse the same timestamp for both markers. **When `CHAT_BOOKENDS` = `Off`**: the same `date` call still runs at response start â€” the timestamp is captured silently (no bookend output) and stored as the response start timestamp for ACTUAL TOTAL COMPLETION TIME (see feature toggle gate "Silent timestamp and estimate capture"). **Exception: post-approval CODING PLAN + CODING START** â€” after `ğŸ“‹ğŸ“‹PLAN APPROVEDğŸ“‹ğŸ“‹`, run a fresh `date` call for the CODING PLAN/CODING START pair; do not reuse the PLAN APPROVED timestamp (see "Continuation after user interaction" rule). When bookends are suppressed, this post-approval `date` call still runs silently. For subsequent bookends mid-response, call `date` inline before writing the marker. End-of-response section headers (AGENTS USED, FILES CHANGED, COMMIT LOG, WORTH NOTING, SUMMARY) do not get timestamps. **The closing marker's `date` call must happen before the END OF RESPONSE BLOCK header** â€” fetch the timestamp, then write the entire end-of-response block (dividers + END OF RESPONSE BLOCK â†’ UNAFFECTED URLS â†’ AGENTS USED â†’ FILES CHANGED â†’ COMMIT LOG â†’ WORTH NOTING â†’ SUMMARY â†’ TODO â†’ NEW FOLDERS â†’ AFFECTED URLS â†’ CODING COMPLETE) as one uninterrupted text output using the pre-fetched timestamp. For RESEARCH COMPLETE responses (no end-of-response block), call `date` before writing ACTUAL TOTAL COMPLETION TIME and RESEARCH COMPLETE
- **Duration annotations (MANDATORY â€” NEVER SKIP)** â€” a `â±ï¸` annotation appears between **every** consecutive pair of bookends (and before the end-of-response block). **No exceptions** â€” if two bookends appear in sequence, there must be a `â±ï¸` line between them. **Procedure for EVERY mid-response bookend** (CHECKLIST, RESEARCHING, NEXT PHASE, BLOCKED, VERIFYING, CHANGES PUSHED, AWAITING HOOK, HOOK FEEDBACK, and the end-of-response block): (1) run `date` via Bash, (2) compute the elapsed time since the previous bookend's timestamp, (3) write `â±ï¸ Xs` (or `Xm Ys` for durations over 60 seconds), (4) THEN write the bookend marker. **The `date` call for the bookend's timestamp and the `â±ï¸` duration can share a single `date` invocation** â€” run `date` once, compute the duration from the previous bookend, write the `â±ï¸` line, then write the bookend with that same timestamp. **You must run `date` to get the current time and compute the difference** â€” never estimate durations mentally. If a phase lasted less than 1 second, write `â±ï¸ <1s`. **The last working phase always gets a `â±ï¸`** â€” its annotation appears immediately before the END OF RESPONSE BLOCK header (as part of the pre-fetched end-of-response block). This includes the gap between the opening marker (CODING START or RESEARCH START) and the next bookend, the gap between AWAITING HOOK and HOOK FEEDBACK, and every other transition. **Self-check**: before writing any bookend, ask yourself: "Did I write a `â±ï¸` line first?" If the answer is no, stop and compute the duration before proceeding
- **Duration before user interaction** â€” before calling `ExitPlanMode` or `AskUserQuestion`, output a `â±ï¸` duration annotation showing how long the preceding phase took (from the last bookend's timestamp to now), followed by `â³â³ACTUAL PLANNING TIME: Xm Ys (estimated Xm)â³â³` comparing the actual planning duration against the overall estimate. The planning time is computed from the response start timestamp to the current moment (when the user is about to be prompted). This makes the planning/research cost visible before the user decides. Run `date`, compute both durations (phase `â±ï¸` and total planning time since the response start), and write both lines immediately before the tool call. After the user responds (plan approved or question answered), the continuation resumes with the next bookend (`ğŸ“‹ğŸ“‹PLAN APPROVEDğŸ“‹ğŸ“‹` or `ğŸ”„ğŸ”„NEXT PHASEğŸ”„ğŸ”„`) as normal

## Hook Anticipation â€” Bug Context

**The failure pattern:** if the hook conditions are evaluated *before* a `git push` completes (or evaluated mentally instead of actually running the git commands), the prediction can be wrong â€” e.g. concluding there are unpushed commits when the push already succeeded. Writing `ğŸŸğŸŸAWAITING HOOKğŸŸğŸŸ` in that case means the hook never fires (because all conditions are actually false), and the conversation gets stuck with no closing marker.

**What to watch for:** any scenario where actions (especially `git push`) complete in the same response as the hook check. The temptation is to predict the outcome rather than wait and verify.

**The fix:** (1) always evaluate *after* all actions in the response are complete, and (2) *actually run* the three git commands â€” never reason about their output mentally.

### Token Budget Reference
*See `repository-information/TOKEN-BUDGETS.md` â€” section "Chat Bookends"*

Developed by: ShadowAISolutions
